/*
 * Figma API
 *
 * This is the OpenAPI specification for the [Figma REST API](https://www.figma.com/developers/api).  Note: we are releasing the OpenAPI specification as a beta given the large surface area and complexity of the REST API. If you notice any inaccuracies with the specification, please [file an issue](https://github.com/figma/rest-api-spec/issues).
 *
 * The version of the OpenAPI document: 0.31.0
 * Contact: support@figma.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`get_file`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFileError {
    Status400(models::BadRequestErrorResponseWithErrMessage),
    Status403(models::ForbiddenErrorResponseWithErrMessage),
    Status404(models::NotFoundErrorResponseWithErrMessage),
    Status429(models::TooManyRequestsErrorResponseWithErrMessage),
    Status500(models::InternalServerErrorResponseWithErrMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_file_meta`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFileMetaError {
    Status400(models::BadRequestErrorResponseWithErrMessage),
    Status403(models::ForbiddenErrorResponseWithErrMessage),
    Status404(models::NotFoundErrorResponseWithErrMessage),
    Status429(models::TooManyRequestsErrorResponseWithErrMessage),
    Status500(models::InternalServerErrorResponseWithErrMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_file_nodes`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFileNodesError {
    Status400(models::BadRequestErrorResponseWithErrMessage),
    Status403(models::ForbiddenErrorResponseWithErrMessage),
    Status404(models::NotFoundErrorResponseWithErrMessage),
    Status429(models::TooManyRequestsErrorResponseWithErrMessage),
    Status500(models::InternalServerErrorResponseWithErrMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_image_fills`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetImageFillsError {
    Status400(models::BadRequestErrorResponseWithErrMessage),
    Status403(models::ForbiddenErrorResponseWithErrMessage),
    Status404(models::NotFoundErrorResponseWithErrMessage),
    Status429(models::TooManyRequestsErrorResponseWithErrMessage),
    Status500(models::InternalServerErrorResponseWithErrMessage),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_images`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetImagesError {
    Status400(models::BadRequestErrorResponseWithErrMessage),
    Status403(models::ForbiddenErrorResponseWithErrMessage),
    Status404(models::NotFoundErrorResponseWithErrMessage),
    Status429(models::TooManyRequestsErrorResponseWithErrMessage),
    Status500(models::InternalServerErrorResponseWithErrMessage),
    UnknownValue(serde_json::Value),
}


/// Returns the document identified by `file_key` as a JSON object. The file key can be parsed from any Figma file url: `https://www.figma.com/file/{file_key}/{title}`.  The `document` property contains a node of type `DOCUMENT`.  The `components` property contains a mapping from node IDs to component metadata. This is to help you determine which components each instance comes from.
pub async fn get_file(configuration: &configuration::Configuration, file_key: &str, version: Option<&str>, ids: Option<&str>, depth: Option<f64>, geometry: Option<&str>, plugin_data: Option<&str>, branch_data: Option<bool>) -> Result<models::GetFile, Error<GetFileError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_file_key = file_key;
    let p_version = version;
    let p_ids = ids;
    let p_depth = depth;
    let p_geometry = geometry;
    let p_plugin_data = plugin_data;
    let p_branch_data = branch_data;

    let uri_str = format!("{}/v1/files/{file_key}", configuration.base_path, file_key=crate::apis::urlencode(p_file_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_version {
        req_builder = req_builder.query(&[("version", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ids {
        req_builder = req_builder.query(&[("ids", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_depth {
        req_builder = req_builder.query(&[("depth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_geometry {
        req_builder = req_builder.query(&[("geometry", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_plugin_data {
        req_builder = req_builder.query(&[("plugin_data", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_branch_data {
        req_builder = req_builder.query(&[("branch_data", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Figma-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetFile`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetFile`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFileError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get file metadata
pub async fn get_file_meta(configuration: &configuration::Configuration, file_key: &str) -> Result<models::GetFileMeta, Error<GetFileMetaError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_file_key = file_key;

    let uri_str = format!("{}/v1/files/{file_key}/meta", configuration.base_path, file_key=crate::apis::urlencode(p_file_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Figma-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetFileMeta`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetFileMeta`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFileMetaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the nodes referenced to by `ids` as a JSON object. The nodes are retrieved from the Figma file referenced to by `file_key`.  The node ID and file key can be parsed from any Figma node url: `https://www.figma.com/file/{file_key}/{title}?node-id={id}`  The `name`, `lastModified`, `thumbnailUrl`, `editorType`, and `version` attributes are all metadata of the specified file.  The `linkAccess` field describes the file link share permission level. There are 5 types of permissions a shared link can have: `\"inherit\"`, `\"view\"`, `\"edit\"`, `\"org_view\"`, and `\"org_edit\"`. `\"inherit\"` is the default permission applied to files created in a team project, and will inherit the project's permissions. `\"org_view\"` and `\"org_edit\"` restrict the link to org users.  The `document` attribute contains a Node of type `DOCUMENT`.  The `components` key contains a mapping from node IDs to component metadata. This is to help you determine which components each instance comes from.  By default, no vector data is returned. To return vector data, pass the geometry=paths parameter to the endpoint. Each node can also inherit properties from applicable styles. The styles key contains a mapping from style IDs to style metadata.  Important: the nodes map may contain values that are `null`. This may be due to the node id not existing within the specified file.
pub async fn get_file_nodes(configuration: &configuration::Configuration, file_key: &str, ids: &str, version: Option<&str>, depth: Option<f64>, geometry: Option<&str>, plugin_data: Option<&str>) -> Result<models::GetFileNodes, Error<GetFileNodesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_file_key = file_key;
    let p_ids = ids;
    let p_version = version;
    let p_depth = depth;
    let p_geometry = geometry;
    let p_plugin_data = plugin_data;

    let uri_str = format!("{}/v1/files/{file_key}/nodes", configuration.base_path, file_key=crate::apis::urlencode(p_file_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("ids", &p_ids.to_string())]);
    if let Some(ref param_value) = p_version {
        req_builder = req_builder.query(&[("version", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_depth {
        req_builder = req_builder.query(&[("depth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_geometry {
        req_builder = req_builder.query(&[("geometry", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_plugin_data {
        req_builder = req_builder.query(&[("plugin_data", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Figma-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetFileNodes`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetFileNodes`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFileNodesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns download links for all images present in image fills in a document. Image fills are how Figma represents any user supplied images. When you drag an image into Figma, we create a rectangle with a single fill that represents the image, and the user is able to transform the rectangle (and properties on the fill) as they wish.  This endpoint returns a mapping from image references to the URLs at which the images may be download. Image URLs will expire after no more than 14 days. Image references are located in the output of the GET files endpoint under the `imageRef` attribute in a `Paint`.
pub async fn get_image_fills(configuration: &configuration::Configuration, file_key: &str) -> Result<models::GetImageFillsResponseBody, Error<GetImageFillsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_file_key = file_key;

    let uri_str = format!("{}/v1/files/{file_key}/images", configuration.base_path, file_key=crate::apis::urlencode(p_file_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Figma-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetImageFillsResponseBody`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetImageFillsResponseBody`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetImageFillsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Renders images from a file.  If no error occurs, `\"images\"` will be populated with a map from node IDs to URLs of the rendered images, and `\"status\"` will be omitted. The image assets will expire after 30 days. Images up to 32 megapixels can be exported. Any images that are larger will be scaled down.  Important: the image map may contain values that are `null`. This indicates that rendering of that specific node has failed. This may be due to the node id not existing, or other reasons such has the node having no renderable components. It is guaranteed that any node that was requested for rendering will be represented in this map whether or not the render succeeded.  To render multiple images from the same file, use the `ids` query parameter to specify multiple node ids.  ``` GET /v1/images/:key?ids=1:2,1:3,1:4 ``` 
pub async fn get_images(configuration: &configuration::Configuration, file_key: &str, ids: &str, version: Option<&str>, scale: Option<f64>, format: Option<&str>, svg_outline_text: Option<bool>, svg_include_id: Option<bool>, svg_include_node_id: Option<bool>, svg_simplify_stroke: Option<bool>, contents_only: Option<bool>, use_absolute_bounds: Option<bool>) -> Result<models::GetImages, Error<GetImagesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_file_key = file_key;
    let p_ids = ids;
    let p_version = version;
    let p_scale = scale;
    let p_format = format;
    let p_svg_outline_text = svg_outline_text;
    let p_svg_include_id = svg_include_id;
    let p_svg_include_node_id = svg_include_node_id;
    let p_svg_simplify_stroke = svg_simplify_stroke;
    let p_contents_only = contents_only;
    let p_use_absolute_bounds = use_absolute_bounds;

    let uri_str = format!("{}/v1/images/{file_key}", configuration.base_path, file_key=crate::apis::urlencode(p_file_key));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("ids", &p_ids.to_string())]);
    if let Some(ref param_value) = p_version {
        req_builder = req_builder.query(&[("version", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_scale {
        req_builder = req_builder.query(&[("scale", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_format {
        req_builder = req_builder.query(&[("format", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_svg_outline_text {
        req_builder = req_builder.query(&[("svg_outline_text", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_svg_include_id {
        req_builder = req_builder.query(&[("svg_include_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_svg_include_node_id {
        req_builder = req_builder.query(&[("svg_include_node_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_svg_simplify_stroke {
        req_builder = req_builder.query(&[("svg_simplify_stroke", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_contents_only {
        req_builder = req_builder.query(&[("contents_only", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_use_absolute_bounds {
        req_builder = req_builder.query(&[("use_absolute_bounds", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{} {}", prefix, key),
            None => key,
        };
        req_builder = req_builder.header("X-Figma-Token", value);
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetImages`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetImages`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetImagesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}


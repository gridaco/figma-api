/*
 * Figma API
 *
 * This is the OpenAPI specification for the [Figma REST API](https://www.figma.com/developers/api).  Note: we are releasing the OpenAPI specification as a beta given the large surface area and complexity of the REST API. If you notice any inaccuracies with the specification, please [file an issue](https://github.com/figma/rest-api-spec/issues).
 *
 * The version of the OpenAPI document: 0.31.0
 * Contact: support@figma.com
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum Node {
    #[serde(rename="BOOLEAN_OPERATION")]
    BooleanOperation(Box<models::BooleanOperationNode>),
    #[serde(rename="COMPONENT")]
    Component(Box<models::ComponentNode>),
    #[serde(rename="COMPONENT_SET")]
    ComponentSet(Box<models::ComponentSetNode>),
    #[serde(rename="CONNECTOR")]
    Connector(Box<models::ConnectorNode>),
    #[serde(rename="ELLIPSE")]
    Ellipse(Box<models::EllipseNode>),
    #[serde(rename="EMBED")]
    Embed(Box<models::EmbedNode>),
    #[serde(rename="FRAME")]
    Frame(Box<models::FrameNode>),
    #[serde(rename="GROUP")]
    Group(Box<models::GroupNode>),
    #[serde(rename="INSTANCE")]
    Instance(Box<models::InstanceNode>),
    #[serde(rename="LINE")]
    Line(Box<models::LineNode>),
    #[serde(rename="LINK_UNFURL")]
    LinkUnfurl(Box<models::LinkUnfurlNode>),
    #[serde(rename="RECTANGLE")]
    Rectangle(Box<models::RectangleNode>),
    #[serde(rename="REGULAR_POLYGON")]
    RegularPolygon(Box<models::RegularPolygonNode>),
    #[serde(rename="SECTION")]
    Section(Box<models::SectionNode>),
    #[serde(rename="SHAPE_WITH_TEXT")]
    ShapeWithText(Box<models::ShapeWithTextNode>),
    #[serde(rename="SLICE")]
    Slice(Box<models::SliceNode>),
    #[serde(rename="STAR")]
    Star(Box<models::StarNode>),
    #[serde(rename="STICKY")]
    Sticky(Box<models::StickyNode>),
    #[serde(rename="TABLE")]
    Table(Box<models::TableNode>),
    #[serde(rename="TABLE_CELL")]
    TableCell(Box<models::TableCellNode>),
    #[serde(rename="TEXT")]
    Text(Box<models::TextNode>),
    #[serde(rename="TEXT_PATH")]
    TextPath(Box<models::TextPathNode>),
    #[serde(rename="TRANSFORM_GROUP")]
    TransformGroup(Box<models::TransformGroupNode>),
    #[serde(rename="VECTOR")]
    Vector(Box<models::VectorNode>),
    #[serde(rename="WASHI_TAPE")]
    WashiTape(Box<models::WashiTapeNode>),
    #[serde(rename="WIDGET")]
    Widget(Box<models::WidgetNode>),
    #[serde(rename="DOCUMENT")]
    Document(Box<models::DocumentNode>),
    #[serde(rename="CANVAS")]
    Canvas(Box<models::CanvasNode>),
}

impl Default for Node {
    fn default() -> Self {
        Self::BooleanOperation(Default::default())
    }
}

/// A string enum indicating the type of boolean operation applied.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum BooleanOperation {
    #[serde(rename = "UNION")]
    Union,
    #[serde(rename = "INTERSECT")]
    Intersect,
    #[serde(rename = "SUBTRACT")]
    Subtract,
    #[serde(rename = "EXCLUDE")]
    Exclude,
}

impl Default for BooleanOperation {
    fn default() -> BooleanOperation {
        Self::Union
    }
}
/// How layer should be treated when the frame is resized
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum ScrollBehavior {
    #[serde(rename = "SCROLLS")]
    Scrolls,
    #[serde(rename = "FIXED")]
    Fixed,
    #[serde(rename = "STICKY_SCROLLS")]
    StickyScrolls,
}

impl Default for ScrollBehavior {
    fn default() -> ScrollBehavior {
        Self::Scrolls
    }
}
///  Determines if the layer should stretch along the parent's counter axis. This property is only provided for direct children of auto-layout frames.  - `INHERIT` - `STRETCH`  In previous versions of auto layout, determined how the layer is aligned inside an auto-layout frame. This property is only provided for direct children of auto-layout frames.  - `MIN` - `CENTER` - `MAX` - `STRETCH`  In horizontal auto-layout frames, \"MIN\" and \"MAX\" correspond to \"TOP\" and \"BOTTOM\". In vertical auto-layout frames, \"MIN\" and \"MAX\" correspond to \"LEFT\" and \"RIGHT\".
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum LayoutAlign {
    #[serde(rename = "INHERIT")]
    Inherit,
    #[serde(rename = "STRETCH")]
    Stretch,
    #[serde(rename = "MIN")]
    Min,
    #[serde(rename = "CENTER")]
    Center,
    #[serde(rename = "MAX")]
    Max,
}

impl Default for LayoutAlign {
    fn default() -> LayoutAlign {
        Self::Inherit
    }
}
/// This property is applicable only for direct children of auto-layout frames, ignored otherwise. Determines whether a layer should stretch along the parent's primary axis. A `0` corresponds to a fixed size and `1` corresponds to stretch.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum LayoutGrow {
    #[serde(rename = "0")]
    Variant0,
    #[serde(rename = "1")]
    Variant1,
}

impl Default for LayoutGrow {
    fn default() -> LayoutGrow {
        Self::Variant0
    }
}
/// Determines whether a layer's size and position should be determined by auto-layout settings or manually adjustable.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum LayoutPositioning {
    #[serde(rename = "AUTO")]
    Auto,
    #[serde(rename = "ABSOLUTE")]
    Absolute,
}

impl Default for LayoutPositioning {
    fn default() -> LayoutPositioning {
        Self::Auto
    }
}
/// The horizontal sizing setting on this auto-layout frame or frame child. - `FIXED` - `HUG`: only valid on auto-layout frames and text nodes - `FILL`: only valid on auto-layout frame children
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum LayoutSizingHorizontal {
    #[serde(rename = "FIXED")]
    Fixed,
    #[serde(rename = "HUG")]
    Hug,
    #[serde(rename = "FILL")]
    Fill,
}

impl Default for LayoutSizingHorizontal {
    fn default() -> LayoutSizingHorizontal {
        Self::Fixed
    }
}
/// The vertical sizing setting on this auto-layout frame or frame child. - `FIXED` - `HUG`: only valid on auto-layout frames and text nodes - `FILL`: only valid on auto-layout frame children
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum LayoutSizingVertical {
    #[serde(rename = "FIXED")]
    Fixed,
    #[serde(rename = "HUG")]
    Hug,
    #[serde(rename = "FILL")]
    Fill,
}

impl Default for LayoutSizingVertical {
    fn default() -> LayoutSizingVertical {
        Self::Fixed
    }
}
/// Position of stroke relative to vector outline, as a string enum  - `INSIDE`: stroke drawn inside the shape boundary - `OUTSIDE`: stroke drawn outside the shape boundary - `CENTER`: stroke drawn centered along the shape boundary
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum StrokeAlign {
    #[serde(rename = "INSIDE")]
    Inside,
    #[serde(rename = "OUTSIDE")]
    Outside,
    #[serde(rename = "CENTER")]
    Center,
}

impl Default for StrokeAlign {
    fn default() -> StrokeAlign {
        Self::Inside
    }
}
/// A string enum with value of \"MITER\", \"BEVEL\", or \"ROUND\", describing how corners in vector paths are rendered.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum StrokeJoin {
    #[serde(rename = "MITER")]
    Miter,
    #[serde(rename = "BEVEL")]
    Bevel,
    #[serde(rename = "ROUND")]
    Round,
}

impl Default for StrokeJoin {
    fn default() -> StrokeJoin {
        Self::Miter
    }
}
/// A string enum describing the end caps of vector paths.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum StrokeCap {
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "ROUND")]
    Round,
    #[serde(rename = "SQUARE")]
    Square,
    #[serde(rename = "LINE_ARROW")]
    LineArrow,
    #[serde(rename = "TRIANGLE_ARROW")]
    TriangleArrow,
    #[serde(rename = "DIAMOND_FILLED")]
    DiamondFilled,
    #[serde(rename = "CIRCLE_FILLED")]
    CircleFilled,
    #[serde(rename = "TRIANGLE_FILLED")]
    TriangleFilled,
    #[serde(rename = "WASHI_TAPE_1")]
    WashiTape1,
    #[serde(rename = "WASHI_TAPE_2")]
    WashiTape2,
    #[serde(rename = "WASHI_TAPE_3")]
    WashiTape3,
    #[serde(rename = "WASHI_TAPE_4")]
    WashiTape4,
    #[serde(rename = "WASHI_TAPE_5")]
    WashiTape5,
    #[serde(rename = "WASHI_TAPE_6")]
    WashiTape6,
}

impl Default for StrokeCap {
    fn default() -> StrokeCap {
        Self::None
    }
}
/// If this layer is a mask, this property describes the operation used to mask the layer's siblings. The value may be one of the following:  - ALPHA: the mask node's alpha channel will be used to determine the opacity of each pixel in the masked result. - VECTOR: if the mask node has visible fill paints, every pixel inside the node's fill regions will be fully visible in the masked result. If the mask has visible stroke paints, every pixel inside the node's stroke regions will be fully visible in the masked result. - LUMINANCE: the luminance value of each pixel of the mask node will be used to determine the opacity of that pixel in the masked result.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum MaskType {
    #[serde(rename = "ALPHA")]
    Alpha,
    #[serde(rename = "VECTOR")]
    Vector,
    #[serde(rename = "LUMINANCE")]
    Luminance,
}

impl Default for MaskType {
    fn default() -> MaskType {
        Self::Alpha
    }
}
/// Whether a node has primary axis scrolling, horizontal or vertical.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum OverflowDirection {
    #[serde(rename = "HORIZONTAL_SCROLLING")]
    HorizontalScrolling,
    #[serde(rename = "VERTICAL_SCROLLING")]
    VerticalScrolling,
    #[serde(rename = "HORIZONTAL_AND_VERTICAL_SCROLLING")]
    HorizontalAndVerticalScrolling,
    #[serde(rename = "NONE")]
    None,
}

impl Default for OverflowDirection {
    fn default() -> OverflowDirection {
        Self::HorizontalScrolling
    }
}
/// Whether this layer uses auto-layout to position its children.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum LayoutMode {
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "HORIZONTAL")]
    Horizontal,
    #[serde(rename = "VERTICAL")]
    Vertical,
}

impl Default for LayoutMode {
    fn default() -> LayoutMode {
        Self::None
    }
}
/// Whether the primary axis has a fixed length (determined by the user) or an automatic length (determined by the layout engine). This property is only applicable for auto-layout frames.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum PrimaryAxisSizingMode {
    #[serde(rename = "FIXED")]
    Fixed,
    #[serde(rename = "AUTO")]
    Auto,
}

impl Default for PrimaryAxisSizingMode {
    fn default() -> PrimaryAxisSizingMode {
        Self::Fixed
    }
}
/// Whether the counter axis has a fixed length (determined by the user) or an automatic length (determined by the layout engine). This property is only applicable for auto-layout frames.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum CounterAxisSizingMode {
    #[serde(rename = "FIXED")]
    Fixed,
    #[serde(rename = "AUTO")]
    Auto,
}

impl Default for CounterAxisSizingMode {
    fn default() -> CounterAxisSizingMode {
        Self::Fixed
    }
}
/// Determines how the auto-layout frame's children should be aligned in the primary axis direction. This property is only applicable for auto-layout frames.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum PrimaryAxisAlignItems {
    #[serde(rename = "MIN")]
    Min,
    #[serde(rename = "CENTER")]
    Center,
    #[serde(rename = "MAX")]
    Max,
    #[serde(rename = "SPACE_BETWEEN")]
    SpaceBetween,
}

impl Default for PrimaryAxisAlignItems {
    fn default() -> PrimaryAxisAlignItems {
        Self::Min
    }
}
/// Determines how the auto-layout frame's children should be aligned in the counter axis direction. This property is only applicable for auto-layout frames.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum CounterAxisAlignItems {
    #[serde(rename = "MIN")]
    Min,
    #[serde(rename = "CENTER")]
    Center,
    #[serde(rename = "MAX")]
    Max,
    #[serde(rename = "BASELINE")]
    Baseline,
}

impl Default for CounterAxisAlignItems {
    fn default() -> CounterAxisAlignItems {
        Self::Min
    }
}
/// Whether this auto-layout frame has wrapping enabled.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum LayoutWrap {
    #[serde(rename = "NO_WRAP")]
    NoWrap,
    #[serde(rename = "WRAP")]
    Wrap,
}

impl Default for LayoutWrap {
    fn default() -> LayoutWrap {
        Self::NoWrap
    }
}
/// Determines how the auto-layout frameâ€™s wrapped tracks should be aligned in the counter axis direction. This property is only applicable for auto-layout frames with `layoutWrap: \"WRAP\"`.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum CounterAxisAlignContent {
    #[serde(rename = "AUTO")]
    Auto,
    #[serde(rename = "SPACE_BETWEEN")]
    SpaceBetween,
}

impl Default for CounterAxisAlignContent {
    fn default() -> CounterAxisAlignContent {
        Self::Auto
    }
}
/// A string enum describing the end cap of the start of the connector.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum ConnectorStartStrokeCap {
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "LINE_ARROW")]
    LineArrow,
    #[serde(rename = "TRIANGLE_ARROW")]
    TriangleArrow,
    #[serde(rename = "DIAMOND_FILLED")]
    DiamondFilled,
    #[serde(rename = "CIRCLE_FILLED")]
    CircleFilled,
    #[serde(rename = "TRIANGLE_FILLED")]
    TriangleFilled,
}

impl Default for ConnectorStartStrokeCap {
    fn default() -> ConnectorStartStrokeCap {
        Self::None
    }
}
/// A string enum describing the end cap of the end of the connector.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum ConnectorEndStrokeCap {
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "LINE_ARROW")]
    LineArrow,
    #[serde(rename = "TRIANGLE_ARROW")]
    TriangleArrow,
    #[serde(rename = "DIAMOND_FILLED")]
    DiamondFilled,
    #[serde(rename = "CIRCLE_FILLED")]
    CircleFilled,
    #[serde(rename = "TRIANGLE_FILLED")]
    TriangleFilled,
}

impl Default for ConnectorEndStrokeCap {
    fn default() -> ConnectorEndStrokeCap {
        Self::None
    }
}
/// An array with the same number of elements as lines in the text node, where lines are delimited by newline or paragraph separator characters. Each element in the array corresponds to the list type of a specific line. List types are represented as string enums with one of these possible values:  - `NONE`: Not a list item. - `ORDERED`: Text is an ordered list (numbered). - `UNORDERED`: Text is an unordered list (bulleted).
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum LineTypes {
    #[serde(rename = "NONE")]
    None,
    #[serde(rename = "ORDERED")]
    Ordered,
    #[serde(rename = "UNORDERED")]
    Unordered,
}

impl Default for LineTypes {
    fn default() -> LineTypes {
        Self::None
    }
}

